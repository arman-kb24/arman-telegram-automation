"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Client", {
  enumerable: true,
  get: function () {
    return _client.Client;
  }
});
Object.defineProperty(exports, "TDL", {
  enumerable: true,
  get: function () {
    return _client.Client;
  }
});
Object.defineProperty(exports, "Tdl", {
  enumerable: true,
  get: function () {
    return _client.Client;
  }
});
Object.defineProperty(exports, "TdlError", {
  enumerable: true,
  get: function () {
    return _client.TdlError;
  }
});
exports.configure = configure;
exports.createClient = createClient;
exports.execute = void 0;
exports.init = init;
exports.setLogMessageCallback = setLogMessageCallback;
var _path = _interopRequireDefault(require("path"));
var _debug = _interopRequireDefault(require("debug"));
var _client = require("./client");
var _addon = require("./addon");
var _util = require("./util");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const debug = (0, _debug.default)('tdl');
let tdjsonAddon = null;

// TODO: Should we export this?
const defaultLibraryFile = (() => {
  switch (process.platform) {
    case 'win32':
      return 'tdjson.dll';
    case 'darwin':
      return 'libtdjson.dylib';
    default:
      return 'libtdjson.so';
  }
})();

// TODO: Use Required<T> from new Flow versions

const defaultReceiveTimeout = 10;
const cfg = {
  tdjson: defaultLibraryFile,
  libdir: '',
  verbosityLevel: 2,
  receiveTimeout: defaultReceiveTimeout,
  useNewTdjsonInterface: false
};
function configure(opts = {}) {
  if (tdjsonAddon) throw Error('TDLib is already initialized; too late to configure');
  if (opts.tdjson != null) cfg.tdjson = opts.tdjson;
  if (opts.libdir != null) cfg.libdir = opts.libdir;
  if (opts.verbosityLevel != null) cfg.verbosityLevel = opts.verbosityLevel;
  if (opts.receiveTimeout != null) cfg.receiveTimeout = opts.receiveTimeout;
  if (opts.useNewTdjsonInterface != null) cfg.useNewTdjsonInterface = opts.useNewTdjsonInterface;
}
function init() {
  if (tdjsonAddon) return;
  debug('Initializing the node addon');
  const lib = _path.default.join(cfg.libdir, cfg.tdjson);
  tdjsonAddon = (0, _addon.loadAddon)(lib);
  if (cfg.verbosityLevel !== 'default') {
    debug('Executing setLogVerbosityLevel', cfg.verbosityLevel);
    const request = JSON.stringify({
      '@type': 'setLogVerbosityLevel',
      new_verbosity_level: cfg.verbosityLevel
    });
    if (cfg.useNewTdjsonInterface) tdjsonAddon.tdn.execute(request);else tdjsonAddon.execute(null, request);
  }
}
const execute = exports.execute = function execute(request) {
  if (!tdjsonAddon) {
    init();
    if (!tdjsonAddon) throw Error('TDLib is uninitialized');
  }
  debug('execute', request);
  request = JSON.stringify((0, _util.deepRenameKey)('_', '@type', request));
  const response = cfg.useNewTdjsonInterface ? tdjsonAddon.tdn.execute(request) : tdjsonAddon.execute(null, request);
  if (response == null) return null;
  return (0, _util.deepRenameKey)('@type', '_', JSON.parse(response));
};
function setLogMessageCallback(maxVerbosityLevel, callback) {
  if (!tdjsonAddon) {
    init();
    if (!tdjsonAddon) throw Error('TDLib is uninitialized');
  }
  tdjsonAddon.setLogMessageCallback(maxVerbosityLevel, callback);
}
const clientMap = new Map();
let tdnInitialized = false;
let runningReceiveLoop = false;

// Loop for the new tdjson interface
async function receiveLoop() {
  debug('Starting receive loop');
  runningReceiveLoop = true;
  try {
    while (true) {
      if (clientMap.size < 1) {
        debug('Stopping receive loop');
        break;
      }
      // $FlowIgnore[incompatible-use]
      const responseString = await tdjsonAddon.tdn.receive();
      if (responseString == null) {
        debug('Receive loop: got empty response');
        continue;
      }
      const res = JSON.parse(responseString);
      const clientId = res['@client_id'];
      const client = clientId != null ? clientMap.get(clientId) : undefined;
      if (client == null) {
        debug(`Cannot find client_id ${clientId}`);
        continue;
      }
      delete res['@client_id']; // Note that delete is somewhat slow
      client.handleReceive(res);
    }
  } finally {
    runningReceiveLoop = false;
  }
}
function createClient(opts) {
  if (!tdjsonAddon) {
    init();
    if (!tdjsonAddon) throw Error('TDLib is uninitialized');
  }
  if (cfg.useNewTdjsonInterface) {
    if (!tdnInitialized) {
      tdjsonAddon.tdn.init(cfg.receiveTimeout);
      tdnInitialized = true;
    }
    const onClose = () => {
      debug(`Deleting client_id ${clientId}`);
      clientMap.delete(clientId);
    };
    const client = new _client.Client(tdjsonAddon, opts, {
      useTdn: true,
      onClose
    });
    const clientId = client.getClientId();
    clientMap.set(clientId, client);
    if (!runningReceiveLoop) receiveLoop();
    return client;
  }
  if (cfg.receiveTimeout !== defaultReceiveTimeout) return new _client.Client(tdjsonAddon, {
    ...opts,
    receiveTimeout: cfg.receiveTimeout
  });
  return new _client.Client(tdjsonAddon, opts);
}

// TODO: We could possibly export an unsafe/unstable getRawTdjson() : Tdjson
// function that allows to access underlying tdjson functions

// For backward compatibility only.